name: PR Build Snap

# JOBs
# 19299607540: a*64= success, armhf=failed

env:
  # DEV can be overridden when manually running this workflow via workflow_dispatch inputs.
  # Default is 'true' to preserve previous behavior.
  DEV: ${{ github.event.inputs.run_id != '' }}
  RUN_ID: ${{ github.event.inputs.run_id }}
  RETENTION_ALL_ARTS: ${{ github.event.inputs.run_id == '' && 1 || 30 }}
  RETENTION_PER_ARTS: ${{ github.event.inputs.run_id == '' && 90 || 1 }}

on:
  pull_request:
    branches:
      - main
    paths-ignore:
      - '.github/**'
      - '.git/**'
      - '.vscode/**'
      - '**/*.md'
      - '**/*.txt'
  workflow_run:
    branches:
      - main
    workflows:
      - "Block non-conforming PRs (auto-close + label)"
    types:
      - completed
  workflow_dispatch:
    inputs:
      run_id: 
        description: "The id of the workflow run where the desired download artifact was uploaded from."
        required: false
        default: ""
      platforms:
        description: "Platforms to build for. If «all», platforms will be defined by snapcraft.yaml. If «from artifact» is selected but run_id is not specified, it will use «all»."
        type: choice
        required: false
        default: "all"
        options:
          - all
          - artifact
          - amd64
          - amd64 arm64
          - amd64 armhf
          - amd64 arm64 armhf
          - arm64
          - arm64 amd64
          - arm64 amd64 armhf
          - armhf
          - armhf arm64
          - armhf arm64 amd64
      # environment:
      #   description: 'Environment to run tests against'
      #   type: environment
      #   required: true
      

permissions:
  contents: read
  actions: read
  pull-requests: write
  issues: write

jobs:
  build:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run == null || github.event.workflow_run.conclusion == 'success' }}
    permissions:
      contents: read
      actions: write
    outputs:
      platforms: ${{ steps.extract.outputs.platforms }}
      artifacts-url: ${{ steps.upload-artifacts.outputs.artifact-url }}
      snapcraft-logs: ${{ steps.build.outputs.snapcraft-log || 'succeeded' }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          #ref: ${{ github.event.workflow_run.head_sha || github.event.pull_request.head.sha || github.ref }}
          fetch-depth: 0

      - name: "Download build artifacts for all platforms"
        uses: actions/download-artifact@v6
        continue-on-error: true
        id: download-artifacts
        # explicit comparison is clearer and avoids edge-cases
        if: ${{ env.DEV == 'true' }}
        with:
          name: snap-build-artifacts
          run-id: ${{ env.RUN_ID || github.run_id }}
          github-token: ${{ secrets.GITHUB_TOKEN }}
          path: .

      - name: Extract platforms from snapcraft.yaml
        id: extract
        run: |
          set -euo pipefail
          archs="$(echo "${{ github.event.inputs.platforms }}" | yq '. | split(" ")' -oj -I0)"

          if [[ "${archs}" == *'artifact'* ]]; then
            if [ "${{ steps.download-artifacts.outcome }}" != "success" ]; then
              archs=
            else
              archs="$(find . -type d \( -name 'arm*' -o -name 'amd*' \) -exec basename {} \; | xargs | yq '. | split(" ")' -oj -I0)"
            fi
          fi

          if [[ -z "${archs}" ]] || [[ "${archs}" == *'all'* ]]; then
            # Output a compact JSON array of platform keys, e.g. ["amd64","arm64"]
            archs=$(yq '.platforms | keys' -oj -I0 snap/snapcraft.yaml)
          fi
          printf 'platforms=%s\n' "$(echo "${archs}" | yq '.' -oj -I0)" >> "$GITHUB_OUTPUT"
          
      - name: Build for ${{ steps.extract.outputs.platforms }}
        id: build
        # if not DEV, or if DEV but download did not succeed
        if: ${{ success() && (env.DEV != 'true' || (env.DEV == 'true' && steps.download-artifacts.outcome != 'success')) }}
        # env:
        #   SNAPCRAFT_STORE_CREDENTIALS: ${{ secrets.SNAPCRAFT_STORE_CREDENTIALS }}
        run: |
          set -exuo pipefail
          
          echo "Run-id: ${{ github.run_id }}"
          echo "Workspace: ${GITHUB_WORKSPACE}, ${HOME}"
          # Read platforms JSON array from previous step
          platforms="$(echo "${{ steps.extract.outputs.platforms }}" | yq '.' -oj -I0)"

          sudo snap install snapcraft --classic
          export SNAPCRAFT_STORE_CREDENTIALS="${{ secrets.SNAPCRAFT_STORE_CREDENTIALS }}" 
          snapcraft whoami || true
          
          mkdir -p ~/.local/share/snapcraft
          echo "${{ secrets.LAUNCHPAD_CREDENTIALS }}" > ~/.local/share/snapcraft/launchpad-credentials
          
          set +e
          # Build for comma-separated list of arches
          snapcraft remote-build -v --launchpad-accept-public-upload \
            --build-for=$(yq '. | join(",")' <<< "$platforms")
          ret=$?
          set -e
          
          find ~ -name "snapcraft-*.log"
          logs=$(find ~ -name "snapcraft*.log" -exec cat {} \;)

          if [ -n "${logs}" ]; then
            set +x
            {
              echo "snapcraft-logs<<EOF"
              echo "${logs}"
              echo "EOF"
            } >> "$GITHUB_OUTPUT"
            set -x
          fi
          
          exit ${ret}
          
      - name: Snapcraft remote log
        if: ${{ steps.build.outcome == 'failure' }}
        run: |
          echo "LOG: ${{ steps.build.outputs.snapcraft-log || 'missing' }}"

      - name: Normalize .snap/.txt artifact names
        # Run if we actually built in this run
        if: ${{ contains(fromJson('["success", "completed"]'), steps.build.outcome) }}
        shell: bash
        run: |
          set -euo pipefail
 
          sn=$(yq '.name' snap/snapcraft.yaml)
          sv=$(yq '.version' snap/snapcraft.yaml)

          # Build root directory
          dst_root=~+/build
          mkdir -p "${dst_root}"

          # Parse platforms JSON array and iterate
          echo '${{ steps.extract.outputs.platforms }}' | jq -r '.[]' | while read p; do
            # Create per-platform directory under dst_root
            platform_dir="${dst_root}/${p}"
            mkdir -p "${platform_dir}"

            find ./ -type f \( -name "${sn}*_${p}.snap" -o -name "*_${p}_*.txt" \) | while read src; do
              ext="${src##*.}"
              # Move files into dst_root with normalized names
              dst="$platform_dir/${sn}_${sv}_${p}.$([[ $ext == "txt" ]] && echo "log" || echo "${ext}")"
              if [ "$(readlink -f "$src")" = "$(readlink -f "$dst")" ]; then
                echo "Source and destination are the same (skipping mv)."
              else
                mv "$src" "$dst"
              fi
            done
          done
          ls -al "$dst_root"
          find "$dst_root" -type f

      - name: Upload build artifacts
        uses: actions/upload-artifact@v5
        id: upload-artifacts
        if: ${{ contains(fromJson('["success", "completed"]'), steps.build.outcome) }}
        with:
          name: snap-build-artifacts
          path: build/
          retention-days: ${{ env.RETENTION_ALL_ARTS }}

  upload:
    needs: build
    runs-on: ubuntu-latest
    permissions:
      actions: write
    strategy:
      matrix:
        platform: ${{ fromJson(needs.build.outputs.platforms) }}
      fail-fast: true
    env:
      PLATFORM: ${{ matrix.platform }}
    steps:
      - name: "Download build artifacts for all platforms"
        uses: actions/download-artifact@v6
        id: download-artifacts
        with:
          run-id: ${{ env.RUN_ID || github.run_id }}
          github-token: ${{ secrets.GITHUB_TOKEN }}
          name: snap-build-artifacts
          path: .

      - name: "Check dir/files for platform (${{ matrix.platform }})"
        id: files
        run: |
          arch="${{ matrix.platform }}"
          echo "Files in workspace (downloaded artifact contents):"
          ls -al ~+/
          ls -al ~+/"${arch}" || true
          echo "dir=${arch}" >> $GITHUB_OUTPUT
          echo "sfn=$(find ~+/"${arch}" -name "*.snap" -print -quit || true)" >> $GITHUB_OUTPUT
          echo "lfn=$(find ~+/"${arch}" -name "*.log" -print -quit || true)" >> $GITHUB_OUTPUT

      - name: "Upload snap for platform (${{ matrix.platform }})"
        id: upload-snap-artifact
        if: ${{ steps.files.outputs.sfn != '' }}
        uses: actions/upload-artifact@v5
        with:
          name: snap-${{ matrix.platform }}
          path: ${{ steps.files.outputs.sfn }}
          retention-days: ${{ env.RETENTION_PER_ARTS }}

      - name: "Download URL snap for platform (${{ matrix.platform }})"
        if: ${{ steps.upload-snap-artifact.outputs.artifact-url }}
        id: snap-artifact
        env:
          URL: ${{ steps.upload-snap-artifact.outputs.artifact-url }}
        run: |
          echo "URL: ${URL}, ${{ steps.upload-snap-artifact.outputs.artifact-url }}"
          echo "url=${URL}" >> $GITHUB_OUTPUT

      - name: "Upload log for platform (${{ matrix.platform }})"
        uses: actions/upload-artifact@v5
        id: upload-log-artifact
        if: ${{ steps.files.outputs.lfn != '' }}
        with:
          name: log-${{ matrix.platform }}
          path: ${{ steps.files.outputs.lfn }}
          retention-days: ${{ env.RETENTION_PER_ARTS }}

      - name: "Download URL log for platform (${{ matrix.platform }})"
        if: ${{ steps.upload-log-artifact.outputs.artifact-url }}
        id: log-artifact
        env:
          URL: ${{ steps.upload-log-artifact.outputs.artifact-url }}
        run: |
          echo "URL: ${URL}, ${{ steps.upload-log-artifact.outputs.artifact-url }}"
          echo "url=${URL}" >> $GITHUB_OUTPUT

      - name: "Write result metadata for platform (${{ matrix.platform }})"
        id: write-result
        run: |
          cat > "${{ matrix.platform }}.json" <<EOF
          {
            "snap-url": "${{ steps.snap-artifact.outputs.url || '' }}",
            "log-url": "${{ steps.log-artifact.outputs.url || '' }}"
          }
          EOF

      - name: "Upload result metadata for platform (${{ matrix.platform }})"
        uses: actions/upload-artifact@v5
        with:
          name: urls-${{ matrix.platform }}
          path: ${{ matrix.platform }}.json

  build-status:
    needs: [build, upload]
    runs-on: ubuntu-latest
    if: ${{ always() }}
    permissions:
      contents: write
      issues: write
    outputs:
      statuses: ${{ steps.statuses.outputs.statuses }}
    env:
      UPLOAD_OK: ${{ needs.upload.outcome == 'success' && 'true' || 'false' }}
    steps:
      - name: "Download all URLS for"
        if: ${{ env.UPLOAD_OK == 'true' }}
        uses: actions/download-artifact@v6
        with:
          pattern: urls-*
          merge-multiple: true
          path: urls
          
      - name: "Download all logs"
        if: ${{ env.UPLOAD_OK == 'true' }}
        uses: actions/download-artifact@v6
        with:
          pattern: log-*
          merge-multiple: true
          path: logs

      - name: Return build statuses
        if: ${{ env.UPLOAD_OK == 'true' }}
        id: build
        env: 
          PLATFORMS: ${{ needs.build.outputs.platforms }}
        run: |
          set -euo pipefail
          status="{}"
          for arch in $(echo "${PLATFORMS}" | yq '. | join(" ")'); do
            echo "Processing architecture: $arch"
            ajon=$(find "${PWD}" -name "*${arch}*.json" -print -quit)

            export built=false
            export logged=false
            if [[ -n "$ajon" ]]; then
              built="$([[ -n "$(cat "$ajon" | yq '.snap-url')" ]] && echo true || echo false)"
              logged="$([[ -n "$(cat "$ajon" | yq '.log-url')" ]] && echo true || echo false)"
            fi
            
            export key=".${arch}"
            status="$(echo "$status" | yq "eval(env(key)) = {\"built\": strenv(built), \"logged\": strenv(logged)}" -oj -I0)"
          done
          
          echo "statuses<<EOF" >> $GITHUB_OUTPUT
          echo "${status}" | yq '.' -oj >> $GITHUB_OUTPUT
          echo EOF >> $GITHUB_OUTPUT
    
      - name: Print status
        if: ${{ env.UPLOAD_OK == 'true' }}
        run: |
          echo "${{ steps.build.outputs.statuses }}"

      - name: "Builds failed for ${{ needs.build.outputs.platforms }}"
        id: archs-logs
        if: ${{ env.UPLOAD_OK != 'true' }}
        run: |
          set -x
          archs="$(echo "${{ needs.build.outputs.platforms }}" | yq '. | join("-")')"
          archs_fn=~+/"snapcraft-${archs}.log"
          echo "${{ needs.build.outputs.snapcraft-logs }}" > "${archs_fn}"
          echo "fn=${archs_fn}" >> $GITHUB_OUTPUT

      - name: "Upload result metadata for platform (${{ matrix.platform }})"
        if: ${{ env.UPLOAD_OK != 'true' }}
        uses: actions/upload-artifact@v5
        with:
          name: snapcraft-archs-logs
          path: ${{ steps.archs-logs.outputs.fn }}

      - name: Statuses
        id: statuses
        run: |
          echo "statuses=${{ steps.build.outputs.statuses || '{"cmd-failed": true}' }}" >> $GITHUB_OUTPUT

  label-build-status:
    needs: build-status
    runs-on: ubuntu-latest
    if: ${{ always() && github.event_name == 'pull_request' }}
    permissions:
      pull-requests: write
      issues: write
    steps:
      - name: Determine and set build status label
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const labelMeta = {
              'build/passed': { color: '0e8a16', description: 'All builds passed' },
              'build/failed': { color: 'b60205', description: 'One or more builds failed' },
              'build/core-failed': { color: 'f9c513', description: 'Snapcraft command failed.' },
              'build/unknown': { color: 'f99113', description: 'Snapcraft command failed.' },
            };

            const statusesJson = `${{ needs.build-status.outputs.statuses }}`;
            core.info(`Build statuses: ${statusesJson}`);
            
            let statuses;
            try {
              statuses = JSON.parse(statusesJson);
            } catch (e) {
              core.error(`Failed to parse statuses JSON: ${e.message}`);
              return;
            }

            // Determine which label to apply based on the logic
            let labelToApply = null;

            // Check if cmd-failed is defined
            if (statuses.hasOwnProperty('cmd-failed')) {
              labelToApply = 'build/core-failed';
            } else {
              // Get all architecture keys
              const archs = Object.keys(statuses);
              
              // Check build statuses
              const allBuilt = archs.every(arch => statuses[arch].built === 'true' || statuses[arch].built === true);
              const anyBuilt = archs.some(arch => statuses[arch].built === 'true' || statuses[arch].built === true);
              const anyFailed = archs.some(arch => statuses[arch].built === 'false' || statuses[arch].built === false);
              const anyNotLogged = archs.some(arch => {
                const built = statuses[arch].built === 'true' || statuses[arch].built === true;
                const logged = statuses[arch].logged === 'true' || statuses[arch].logged === true;
                return built && !logged;
              });

              // Apply label based on priority
              if (anyFailed) {
                labelToApply = 'build/failed';
              } else if (allBuilt && anyNotLogged) {
                labelToApply = 'build/unknown';
              } else if (allBuilt) {
                labelToApply = 'build/passed';
              }
            }

            if (!labelToApply) {
              core.info('No label to apply based on current statuses.');
              return;
            }

            core.info(`Label to apply: ${labelToApply}`);

            const prNumber = context.issue.number;
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            // Ensure the label exists; create if missing
            const labelInfo = labelMeta[labelToApply];
            try {
              await github.rest.issues.getLabel({
                owner,
                repo,
                name: labelToApply
              });
              core.info(`Label '${labelToApply}' already exists.`);
            } catch (err) {
              if (err && err.status === 404) {
                core.info(`Label '${labelToApply}' not found — creating it.`);
                await github.rest.issues.createLabel({
                  owner,
                  repo,
                  name: labelToApply,
                  color: labelInfo.color,
                  description: labelInfo.description
                });
              } else {
                throw err;
              }
            }

            // Remove any existing build/* labels first
            const existingLabels = await github.rest.issues.listLabelsOnIssue({
              owner,
              repo,
              issue_number: prNumber
            });

            const buildLabels = existingLabels.data
              .map(label => label.name)
              .filter(name => name.startsWith('build/'));

            for (const label of buildLabels) {
              if (label !== labelToApply) {
                core.info(`Removing old build label: ${label}`);
                await github.rest.issues.removeLabel({
                  owner,
                  repo,
                  issue_number: prNumber,
                  name: label
                });
              }
            }

            // Add the new label
            if (!buildLabels.includes(labelToApply)) {
              core.info(`Adding label: ${labelToApply}`);
              await github.rest.issues.addLabels({
                owner,
                repo,
                issue_number: prNumber,
                labels: [labelToApply]
              });
            } else {
              core.info(`Label '${labelToApply}' already applied.`);
            }
