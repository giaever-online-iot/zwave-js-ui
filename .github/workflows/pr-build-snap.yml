name: PR Build Snap

on:
  pull_request:
    branches:
      - main
    paths-ignore:
      - '.github/**'

jobs:
  wait-for-policy-check:
    runs-on: ubuntu-latest
    steps:
      - name: Wait for PR policy enforcement
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const maxWaitTime = 10 * 60 * 1000; // 10 minutes
            const pollInterval = 10 * 1000; // 10 seconds
            const startTime = Date.now();
            
            // Get the current PR number
            const prNumber = context.payload.pull_request?.number;
            if (!prNumber) {
              core.setFailed('No PR number found in context');
              return;
            }
            
            core.info(`Waiting for Block non-conforming PRs workflow to complete for PR #${prNumber}...`);
            
            while (Date.now() - startTime < maxWaitTime) {
              // Get workflow runs for the PR
              const { data: workflowRuns } = await github.rest.actions.listWorkflowRunsForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                event: 'pull_request_target',
                per_page: 100
              });
              
              // Find the most recent workflow run for this PR from the block-fork-prs workflow
              const relevantRun = workflowRuns.workflow_runs.find(run => {
                // Check if this run is associated with our PR
                return run.pull_requests?.some(pr => pr.number === prNumber) &&
                       run.name === 'Block non-conforming PRs (auto-close + label)';
              });
              
              if (relevantRun) {
                core.info(`Found workflow run: ${relevantRun.html_url} with status: ${relevantRun.status}, conclusion: ${relevantRun.conclusion}`);
                
                if (relevantRun.status === 'completed') {
                  if (relevantRun.conclusion === 'success') {
                    core.info('âœ“ PR policy check passed!');
                    return;
                  } else {
                    core.setFailed(`PR policy check failed with conclusion: ${relevantRun.conclusion}`);
                    return;
                  }
                }
                
                core.info('Policy check still running, waiting...');
              } else {
                core.info('Policy check workflow not found yet, waiting...');
              }
              
              // Wait before polling again
              await new Promise(resolve => setTimeout(resolve, pollInterval));
            }
            
            core.setFailed('Timeout waiting for PR policy check to complete');

  build:
    needs: wait-for-policy-check
    runs-on: ubuntu-latest
    outputs:
      platforms: ${{ steps.build.outputs.platforms }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Extract platforms from snapcraft.yaml
        id: extract
        run: |
          # Output a compact JSON array of platform keys, e.g. ["amd64","arm64"]
          # echo "platforms=$(yq '.platforms | keys' -oj -I0 snap/snapcraft.yaml)" >> $GITHUB_OUTPUT
          echo "platforms=$(echo "['amd64']" | yq '.' -oj -I0)" >> $GITHUB_OUTPUT

      - name: Build for ${{ steps.extract.outputs.platforms }}
        id: build
        run: |
          set -xuo pipefail

          # Read platforms JSON array from previous step
          # Convert array to mapping: {"amd64": {}, "arm64": {}}
          platforms_map="$(echo "${{ steps.extract.outputs.platforms}}" | yq 'to_entries | map({"key": .value, "value": {}}) | from_entries' -oj -I0)"

          sudo snap install snapcraft --classic
          export SNAPCRAFT_STORE_CREDENTIALS="${{ secrets.SNAPCRAFT_STORE_CREDENTIALS }}"
          snapcraft whoami || true
          mkdir -p ~/.local/share/snapcraft
          echo "${{ secrets.LAUNCHPAD_CREDENTIALS }}" > ~/.local/share/snapcraft/launchpad-credentials

          # Build for comma-separated list of arches
          snapcraft remote-build -v --launchpad-accept-public-upload \
            --build-for=$(jq -r 'keys | join(",")' <<< "$platforms_map")

          # Collect artifacts per arch
          for p in $(jq -r 'keys[]' <<< "$platforms_map"); do
            sfn=$(ls -d "${PWD}"/zwave-js-ui*_"${p}".snap 2>/dev/null || true)
            lfn=$(ls -d "${PWD}"/snapcraft-*_"${p}"_*.txt 2>/dev/null || true)

            if [[ -n "$sfn" ]]; then
              platforms_map=$(jq --arg p "$p" --arg sfn "$sfn" '.[$p].sfn = $sfn' <<< "$platforms_map")
            else
              platforms_map=$(jq --arg p "$p" '.[$p].sfn = ""' <<< "$platforms_map")
            fi

            platforms_map=$(jq --arg p "$p" --arg lfn "$lfn" '.[$p].lfn = $lfn' <<< "$platforms_map")
          done

          # Convert mapping to array of objects: [{arch: "amd64", sfn: "...", lfn: "..."}, ...]
          platforms_array=$(jq -c 'to_entries | map({arch:.key} + .value)' <<< "$platforms_map")

          echo "$platforms_array"
          echo "platforms=$platforms_array" >> $GITHUB_OUTPUT

  upload:
    needs: build 
    runs-on: ubuntu-latest
    strategy:
      matrix:
        platform: ${{ fromJson(needs.build.outputs.platforms) }}
      fail-fast: true
    steps:
      - name: For build platform ${{ matrix.platform.arch }}
        id: file
        run: |
          set -euo pipefail
          sfn="${{ matrix.platform.sfn }}"
          lfn="${{ matrix.platform.lfn }}"
          echo "paths<<EOF" >> "$GITHUB_OUTPUT"
          if [ -n "${sfn}" ] && [ -f "${sfn}" ]; then
            echo "${sfn}" >> "$GITHUB_OUTPUT"
          fi
          if [ -n "${lfn}" ] && [ -f "${lfn}" ]; then
            echo "${lfn}" >> "$GITHUB_OUTPUT"
          fi
          echo "EOF" >> "$GITHUB_OUTPUT"

      - name: Upload ${{ matrix.platform.arch }}
        uses: actions/upload-artifact@v5
        id: upload
        if: ${{ steps.file.outputs.paths != '' }}
        with:
          name: ${{ matrix.platform.arch }}
          path: ${{ steps.file.outputs.paths }}
        



          
